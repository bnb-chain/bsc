// Copyright 2014 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see <http://www.gnu.org/licenses/>.

package vm

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/ethereum/go-ethereum/common"
)

// GenerateShortcutFile 生成Shortcut实现文件
func GenerateShortcutFile(contractAddr common.Address, opcodes []byte, outputDir string) error {
	// 生成代码
	code, err := GenerateShortcutForContract(contractAddr, opcodes)
	if err != nil {
		return fmt.Errorf("生成Shortcut代码失败: %v", err)
	}

	// 确保输出目录存在
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("创建输出目录失败: %v", err)
	}

	// 生成文件名
	fileName := fmt.Sprintf("contract_%s.go", contractAddr.Hex()[2:])
	filePath := filepath.Join(outputDir, fileName)

	// 写入文件
	if err := os.WriteFile(filePath, []byte(code), 0644); err != nil {
		return fmt.Errorf("写入文件失败: %v", err)
	}

	fmt.Printf("成功生成Shortcut文件: %s\n", filePath)
	return nil
}

// ExampleGenerateERC20Shortcut 示例：生成ERC20代币的Shortcut代码
func ExampleGenerateERC20Shortcut() {
	// ERC20代币合约地址 (USDT)
	contractAddr := common.HexToAddress("0x55d398326f99059ff775485246999027b3197955")

	// ERC20代币的典型opcode序列
	// 这里是一个简化的ERC20合约opcode序列
	opcodes := []byte{
		// 函数选择器分发器
		// totalSupply()
		0x63, 0x18, 0x16, 0x0d, 0xdd, // PUSH4 0x18160ddd
		0x80,                         // DUP1
		0x63, 0xff, 0xff, 0xff, 0xff, // PUSH4 0xffffffff
		0x16,             // AND
		0x14,             // EQ
		0x61, 0x00, 0x30, // PUSH2 0x0030
		0x57, // JUMPI

		// balanceOf(address)
		0x63, 0x70, 0xa0, 0x82, 0x31, // PUSH4 0x70a08231
		0x80,                         // DUP1
		0x63, 0xff, 0xff, 0xff, 0xff, // PUSH4 0xffffffff
		0x16,             // AND
		0x14,             // EQ
		0x61, 0x00, 0x50, // PUSH2 0x0050
		0x57, // JUMPI

		// transfer(address,uint256)
		0x63, 0xa9, 0x05, 0x9c, 0xbb, // PUSH4 0xa9059cbb
		0x80,                         // DUP1
		0x63, 0xff, 0xff, 0xff, 0xff, // PUSH4 0xffffffff
		0x16,             // AND
		0x14,             // EQ
		0x61, 0x00, 0x70, // PUSH2 0x0070
		0x57, // JUMPI

		// transferFrom(address,address,uint256)
		0x63, 0x23, 0xb8, 0x72, 0xdd, // PUSH4 0x23b872dd
		0x80,                         // DUP1
		0x63, 0xff, 0xff, 0xff, 0xff, // PUSH4 0xffffffff
		0x16,             // AND
		0x14,             // EQ
		0x61, 0x00, 0x90, // PUSH2 0x0090
		0x57, // JUMPI

		// approve(address,uint256)
		0x63, 0x09, 0x5e, 0xa7, 0xb3, // PUSH4 0x095ea7b3
		0x80,                         // DUP1
		0x63, 0xff, 0xff, 0xff, 0xff, // PUSH4 0xffffffff
		0x16,             // AND
		0x14,             // EQ
		0x61, 0x00, 0xb0, // PUSH2 0x00b0
		0x57, // JUMPI

		// allowance(address,address)
		0x63, 0xdd, 0x62, 0xed, 0x3e, // PUSH4 0xdd62ed3e
		0x80,                         // DUP1
		0x63, 0xff, 0xff, 0xff, 0xff, // PUSH4 0xffffffff
		0x16,             // AND
		0x14,             // EQ
		0x61, 0x00, 0xd0, // PUSH2 0x00d0
		0x57, // JUMPI

		// 填充字节
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

		// totalSupply函数体 (PC=48)
		0x60, 0x00, // PUSH1 0x00
		0x54,       // SLOAD (从存储加载总供应量)
		0x60, 0x00, // PUSH1 0x00
		0x52,       // MSTORE
		0x60, 0x20, // PUSH1 0x20
		0x60, 0x00, // PUSH1 0x00
		0xf3, // RETURN

		// 填充字节
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

		// balanceOf函数体 (PC=80)
		0x60, 0x04, // PUSH1 0x04
		0x35,       // CALLDATALOAD (加载地址参数)
		0x60, 0x00, // PUSH1 0x00
		0x52,       // MSTORE
		0x60, 0x20, // PUSH1 0x20
		0x60, 0x00, // PUSH1 0x00
		0xf3, // RETURN

		// 填充字节
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

		// transfer函数体 (PC=112)
		0x60, 0x04, // PUSH1 0x04
		0x35,       // CALLDATALOAD (加载to地址)
		0x60, 0x24, // PUSH1 0x24
		0x35,       // CALLDATALOAD (加载amount)
		0x60, 0x00, // PUSH1 0x00
		0x52,       // MSTORE
		0x60, 0x20, // PUSH1 0x20
		0x60, 0x00, // PUSH1 0x00
		0xf3, // RETURN

		// 填充字节
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

		// transferFrom函数体 (PC=144)
		0x60, 0x04, // PUSH1 0x04
		0x35,       // CALLDATALOAD (加载from地址)
		0x60, 0x24, // PUSH1 0x24
		0x35,       // CALLDATALOAD (加载to地址)
		0x60, 0x44, // PUSH1 0x44
		0x35,       // CALLDATALOAD (加载amount)
		0x60, 0x00, // PUSH1 0x00
		0x52,       // MSTORE
		0x60, 0x20, // PUSH1 0x20
		0x60, 0x00, // PUSH1 0x00
		0xf3, // RETURN

		// 填充字节
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

		// approve函数体 (PC=176)
		0x60, 0x04, // PUSH1 0x04
		0x35,       // CALLDATALOAD (加载spender地址)
		0x60, 0x24, // PUSH1 0x24
		0x35,       // CALLDATALOAD (加载amount)
		0x60, 0x00, // PUSH1 0x00
		0x52,       // MSTORE
		0x60, 0x20, // PUSH1 0x20
		0x60, 0x00, // PUSH1 0x00
		0xf3, // RETURN

		// 填充字节
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

		// allowance函数体 (PC=208)
		0x60, 0x04, // PUSH1 0x04
		0x35,       // CALLDATALOAD (加载owner地址)
		0x60, 0x24, // PUSH1 0x24
		0x35,       // CALLDATALOAD (加载spender地址)
		0x60, 0x00, // PUSH1 0x00
		0x52,       // MSTORE
		0x60, 0x20, // PUSH1 0x20
		0x60, 0x00, // PUSH1 0x00
		0xf3, // RETURN
	}

	// 生成Shortcut代码
	code, err := GenerateShortcutForContract(contractAddr, opcodes)
	if err != nil {
		fmt.Printf("生成失败: %v\n", err)
		return
	}

	fmt.Println("=== ERC20代币Shortcut代码生成示例 ===")
	fmt.Printf("合约地址: %s\n", contractAddr.Hex())
	fmt.Printf("识别到的函数选择器:\n")
	fmt.Printf("  - totalSupply(): 0x18160ddd\n")
	fmt.Printf("  - balanceOf(address): 0x70a08231\n")
	fmt.Printf("  - transfer(address,uint256): 0xa9059cbb\n")
	fmt.Printf("  - transferFrom(address,address,uint256): 0x23b872dd\n")
	fmt.Printf("  - approve(address,uint256): 0x095ea7b3\n")
	fmt.Printf("  - allowance(address,address): 0xdd62ed3e\n")
	fmt.Println("\n生成的代码:")
	fmt.Println(code)

	// 可选：保存到文件
	outputDir := "../../core/opcodeCompiler/shortcut/impl"
	if err := GenerateShortcutFile(contractAddr, opcodes, outputDir); err != nil {
		fmt.Printf("保存文件失败: %v\n", err)
	}
}

// ExampleGenerateNFTShortcut 示例：生成NFT合约的Shortcut代码
func ExampleGenerateNFTShortcut() {
	// NFT合约地址
	contractAddr := common.HexToAddress("0x1234567890123456789012345678901234567890")

	// NFT合约的典型opcode序列
	opcodes := []byte{
		// 函数选择器分发器
		// balanceOf(address)
		0x63, 0x70, 0xa0, 0x82, 0x31, // PUSH4 0x70a08231
		0x80,                         // DUP1
		0x63, 0xff, 0xff, 0xff, 0xff, // PUSH4 0xffffffff
		0x16,             // AND
		0x14,             // EQ
		0x61, 0x00, 0x30, // PUSH2 0x0030
		0x57, // JUMPI

		// ownerOf(uint256)
		0x63, 0x63, 0x5f, 0x15, 0x1f, // PUSH4 0x635f151f
		0x80,                         // DUP1
		0x63, 0xff, 0xff, 0xff, 0xff, // PUSH4 0xffffffff
		0x16,             // AND
		0x14,             // EQ
		0x61, 0x00, 0x50, // PUSH2 0x0050
		0x57, // JUMPI

		// transferFrom(address,address,uint256)
		0x63, 0x23, 0xb8, 0x72, 0xdd, // PUSH4 0x23b872dd
		0x80,                         // DUP1
		0x63, 0xff, 0xff, 0xff, 0xff, // PUSH4 0xffffffff
		0x16,             // AND
		0x14,             // EQ
		0x61, 0x00, 0x70, // PUSH2 0x0070
		0x57, // JUMPI

		// 填充字节
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

		// balanceOf函数体 (PC=48)
		0x60, 0x04, // PUSH1 0x04
		0x35,       // CALLDATALOAD
		0x60, 0x00, // PUSH1 0x00
		0x52,       // MSTORE
		0x60, 0x20, // PUSH1 0x20
		0x60, 0x00, // PUSH1 0x00
		0xf3, // RETURN

		// 填充字节
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

		// ownerOf函数体 (PC=80)
		0x60, 0x04, // PUSH1 0x04
		0x35,       // CALLDATALOAD
		0x60, 0x00, // PUSH1 0x00
		0x52,       // MSTORE
		0x60, 0x20, // PUSH1 0x20
		0x60, 0x00, // PUSH1 0x00
		0xf3, // RETURN

		// 填充字节
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

		// transferFrom函数体 (PC=112)
		0x60, 0x04, // PUSH1 0x04
		0x35,       // CALLDATALOAD
		0x60, 0x24, // PUSH1 0x24
		0x35,       // CALLDATALOAD
		0x60, 0x44, // PUSH1 0x44
		0x35,       // CALLDATALOAD
		0x60, 0x00, // PUSH1 0x00
		0x52,       // MSTORE
		0x60, 0x20, // PUSH1 0x20
		0x60, 0x00, // PUSH1 0x00
		0xf3, // RETURN
	}

	// 生成Shortcut代码
	code, err := GenerateShortcutForContract(contractAddr, opcodes)
	if err != nil {
		fmt.Printf("生成失败: %v\n", err)
		return
	}

	fmt.Println("\n=== NFT合约Shortcut代码生成示例 ===")
	fmt.Printf("合约地址: %s\n", contractAddr.Hex())
	fmt.Printf("识别到的函数选择器:\n")
	fmt.Printf("  - balanceOf(address): 0x70a08231\n")
	fmt.Printf("  - ownerOf(uint256): 0x635f151f\n")
	fmt.Printf("  - transferFrom(address,address,uint256): 0x23b872dd\n")
	fmt.Println("\n生成的代码:")
	fmt.Println(code)
}

// 主函数示例
func ExampleMain() {
	fmt.Printf("=== Shortcut代码生成器示例 ===\n")

	// 生成ERC20代币的Shortcut代码
	ExampleGenerateERC20Shortcut()

	fmt.Println("\n" + strings.Repeat("=", 50) + "\n")

	// 生成NFT合约的Shortcut代码
	ExampleGenerateNFTShortcut()
}
